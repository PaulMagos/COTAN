---
title: "Guided tutorial as V.1"
author: 
- name: "Silvia Giulia GalfrÃ¨"
  affiliation: "Department of Computer Science, University of Pisa"
- name: "Marco Fantozzi"
  
package: COTAN
output: 
    BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Guided tutorial as V.2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5,
  fig.height = 5
)
```

```{r message=FALSE, warning=FALSE}
options(parallelly.fork.enable = TRUE)
library(COTAN)
library(zeallot)
library(data.table)
library(factoextra)
library(Rtsne)
library(qpdf)
library(GEOquery)
```

## Introduction

This tutorial contains the new functionalities introduced in the second release
of the COTAN package.

## Get the data-set

Download the data-set for mouse cortex E17.5.

```{r eval=TRUE, include=TRUE}
dataDir <- tempdir()

dataSetFile <- file.path(dataDir, "GSM2861514/GSM2861514_E175_Only_Cortical_Cells_DGE.txt.gz")

if (!file.exists(dataSetFile)) {
  getGEOSuppFiles("GSM2861514", makeDirectory = TRUE,
                  baseDir = dataDir, fetch_files = TRUE,
                  filter_regex = "GSM2861514_E175_Only_Cortical_Cells_DGE.txt.gz")
  sample.dataset <- read.csv(dataSetFile, sep = "\t", row.names = 1L)
}
```

Define a directory where the output will be stored.

```{r}
outDir <- tempdir()

# Log-level 2 was chosen to better showcase how the package works
# In normal usage a level of 0 or 1 is more appropriate 
setLoggingLevel(2)

# This file will contain all the logs produced by the package
# as if at the highest logging level
setLoggingFile(file.path(outDir, "vignette_v2.log"))
```

# Analytical pipeline

Initialize the `COTAN` object with the row count table and
the metadata for the experiment.

```{r}
#obj = COTAN(raw = sampled.dataset)
obj = COTAN(raw = sample.dataset)
obj = initializeMetaDataset(obj, GEO = "GSM2861514",
                            sequencingMethod = "Drop_seq",
                            sampleCondition = "mouse cortex E17.5")
```

Before we proceed to the analysis, we need to clean the data.
The analysis will follow the steps outlined in the `Guided_tutorial_v1`,
here are just the final steps to prepare the data-set.

## Data cleaning

```{r}
cells_to_rem <- getCells(obj)[getCellsSize(obj) > 6000]
obj <- dropGenesCells(obj, cells = cells_to_rem)

cellGeneNumber <- sort(colSums(as.data.frame(getRawData(obj) > 0)),
                       decreasing = FALSE)
cells_to_rem <- names(cellGeneNumber)[cellGeneNumber > 3000]
obj <- dropGenesCells(obj, cells = cells_to_rem)

mit <- mitochondrialPercentagePlot(obj, genePrefix = "^Mt")
to_rem <- mit[["sizes"]][["mit.percentage"]] > 1.5
cells_to_rem <- rownames(mit[["sizes"]])[to_rem]
obj <- dropGenesCells(obj, cells = cells_to_rem)

genes_to_rem = getGenes(obj)[grep('^Mt', getGenes(obj))] 
cells_to_rem = getCells(obj)[which(getCellsSize(obj) == 0)]
obj = dropGenesCells(obj, genes_to_rem, cells_to_rem)

obj <- clean(obj)
c(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %<-% cleanPlots(obj)

cells_to_rem <- rownames(pcaCellsData)[pcaCellsData[["groups"]] == "B"]
obj <- dropGenesCells(obj, cells = cells_to_rem)
 
obj <- clean(obj)

nuDf = data.frame("nu" = sort(getNu(obj)), "n" = seq_along(getNu(obj)))
yset = 0.35 # the threshold to remove low UDE cells
cells_to_rem = rownames(nuDf)[nuDf[["nu"]] < yset]
obj <- dropGenesCells(obj, cells = cells_to_rem)

obj <- clean(obj)
c(pcaCellsPlot, pcaCellsData, genesPlot, UDEPlot, nuPlot) %<-% cleanPlots(obj)

pcaCellsPlot
```

We want also to define a prefix to identify the sample.

```{r}
t = "E17.5_cortex"

logThis(paste0("Condition ", t), logLevel = 1)
logThis(paste("n cells", getNumCells(obj)), logLevel = 1)
```

## COTAN analysis

In this part, all the contingency tables are computed and used to get the statistics.

```{r}
obj = estimateDispersionBisection(obj, cores = 10)
```

COEX evaluation and storing

```{r}
obj <- calculateCoex(obj)
```

```{r eval=FALSE, include=TRUE}
# saving the structure
saveRDS(obj, file = file.path(outDir, paste0(t, ".cotan.RDS")))
```


```{r}
genesList <- list(
"NPGs"=c("Nes","Vim","Sox2","Sox1","Notch1", "Hes1","Hes5","Pax6"),
"PNGs"=c("Map2","Tubb3","Neurod1","Nefm","Nefl","Dcx","Tbr1"),
"hk"=c("Calm1","Cox6b1","Ppia","Rpl18","Cox7c","Erh","H3f3a","Taf1","Taf2",
       "Gapdh","Actb","Golph3",  "Zfr", "Sub1", "Tars", "Amacr")
)

layersGenes = list("L1"=c("Reln","Lhx5"), "L2/3"=c("Satb2","Cux1"), "L4"=c("Rorb","Sox5") , "L5/6"=c("Bcl11b","Fezf2") , "Prog"=c("Vim","Hes1"))


c(gSpace, eigPlot, pcaClustersDF, treePlot) %<-%
  establishGenesClusters(obj, groupMarkers = layersGenes,
                         numGenesPerMarker = 25, kCuts = 6)

# tmpList contains "g.space", "plot.eig", "pca_clusters", "tree_plot"
plot(eigPlot)
```

```{r}
plot(treePlot)
```

```{r}
UMAPPlot(pcaClustersDF[, 1:10], 
         clusters = pcaClustersDF[["hclust"]],
         elements = layersGenes,
         title = "Genes' clusters UMAP Plot")
```

### Uniform Clustering

It is possible to obtain a cell clusterization based on the concept of 
uniformity of expression of the genes across the cells. That is the cluster
satisfies the null hypothesis of the `COTAN` model:
the genes expression is not dependent on the cell in consideration.

```{r}
fineClusters <- cellsUniformClustering(obj, GDIThreshold = 1.4, cores = 10,
                                       saveObj = TRUE, outDir = outDir)

obj <- addClusterization(obj, clName = "FineClusters", clusters = fineClusters)
```


```{r}
c(coexDF, pValueDF) %<-% DEAOnClusters(obj, clusters = fineClusters)

obj <- addClusterizationCoex(obj, clName = "FineClusters",
                             coexDF = coexDF)
```


```{r}
fineUMAPPlot <- UMAPPlot(coexDF, title = "Fine Cluster UMAP Plot")

plot(fineUMAPPlot)
```


```{r}
c(mergedClusters, coexDF, pValueDF) %<-%
  mergeUniformCellsClusters(obj, GDIThreshold = 1.4, cores = 10,
                            saveObj = TRUE, outDir = outDir)

obj <- addClusterization(obj, clName = "MergedClusters",
                         clusters = mergedClusters, coexDF = coexDF)
```


```{r}
mergedUMAPPlot <- UMAPPlot(coexDF, title = "Fine Cluster UMAP Plot")

plot(mergedUMAPPlot)
```


The next few lines are just to clean.

```{r}
if (file.exists(file.path(outDir, paste0(t, ".cotan.RDS")))) {
  #Delete file if it exists
  file.remove(file.path(outDir, paste0(t, ".cotan.RDS")))
}
unlink(file.path(outDir, getMetadataElement(obj, tag = datasetTags()[["cond"]])),
       recursive = TRUE)
file.remove(dataSetFile)

sessionInfo()
```
