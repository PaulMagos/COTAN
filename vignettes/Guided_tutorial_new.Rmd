---
title: "Guided tutorial new"
author: 
- name: "Silvia Giulia GalfrÃ¨"
  affiliation: "Department of Biology, University of Rome Tor Vergata"
- name: "Francesco Morandin"
  affiliation: "Department of Mathematical, Physical and Computer Sciences, University of Parma"
- name: "Marco  Pietrosanto"
  affiliation: "Department of Biology, University of Rome Tor Vergata"
- name: "Federico Cremisi"
  affiliation: "Scuola Normale Superiore di Pisa"
- name: "Manuela Helmer-Citterich"
  affiliation: "Department of Biology, University of Rome Tor Vergata"
- name: "Marco Fantozzi"
  affiliation: "None [freelance]"
package: COTAN
output: 
    BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Guided tutorial new}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8} 
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5,
  fig.height = 5
)

```

```{r}
library(COTAN)
library(data.table)
library(Matrix)
library(ggrepel)
library(factoextra)
library(Rtsne)
library(utils)
library(plotly)
library(tidyverse)
library(htmlwidgets)
library(MASS)
library(zeallot)
library(grDevices)
#library(dendextend)

# Log-level 2 was chosen to showcase better how the package works
# In normal usage a level of 0 or 1 is more appropriate 
setLoggingLevel(2)
```

Download the dataset for mouse cortex E17.5.

```{r eval=FALSE, include=FALSE}
data_dir = tempdir()
if (FALSE && !file.exists(file.path(dataDir, "E175_only_cortical_cells.txt.gz"))) {
  download.file(paste0("ftp://ftp.ncbi.nlm.nih.gov/geo/samples/",
                       "GSM2861nnn/GSM2861514/suppl/",
                       "GSM2861514_E175_Only_Cortical_Cells_DGE.txt.gz"),
                file.path(dataDir, "/E175_only_cortical_cells.txt.gz"),
                method = "wget", quiet = FALSE)
}
```

This is just an example of a toy dataset. If the user wants to try on a real dataset, they can be used the previous command to download it and the next commented line to use as input data. There are also available online many other examples at the [link](https://seriph78.github.io/Cotan_paper/index.html).

```{r}
data("test.dataset.col", package = "COTAN")

#rownames(ERCCraw) = ERCCraw$V1
#ERCCraw = ERCCraw[,2:ncol(ERCCraw)]
#ERCCraw[1:5,1:5]
```

Define a directory where the output will be stored.

```{r}
outDir <- tempdir()
```

# Analytical pipeline

Initialize the `COTAN` object with the row count table and the metadata for the experiment.

```{r}
obj = COTAN(raw = test.dataset.col)
#obj = initializeMetaDataset(obj, GEO = "GSM2861514",
#                            sequencingMethod = "Drop_seq",
#                            sampleCondition = "mouse cortex E17.5")
obj = initializeMetaDataset(obj, GEO = "test",
                            sequencingMethod = "10X",
                            sampleCondition = "test_dataset")
```

Now we can start the cleaning. Analysis requires and starts from a matrix of raw UMI counts after removing possible cell doublets or multiplets and low quality or dying cells (with too high mtRNA percentage, easily done with Seurat or other tools).

If we do not want to consider the mitochondrial genes we can remove them before starting the analysis.

```{r}
genes_to_rem = getGenes(obj)[grep('^MT', getGenes(obj))] 
cells_to_rem = getCells(obj)[which(getCellsSize(obj) == 0)]
obj = dropGenesCells(obj, genes_to_rem, cells_to_rem)
```

We want also to define a prefix to identify the sample.

```{r}
#t = "E17.5_cortex"
t = "test"

logThis(paste0("Condition ", t), logLevel = 1)
#--------------------------------------
logThis(paste("n cells", getNumCells(obj)), logLevel = 1)

n_it = 1
```

## Data cleaning

First, we create a directory to store all information regarding the data cleaning.

```{r}
if(!file.exists(outDir)){
  dir.create(file.path(outDir))
}

if(!file.exists(file.path(outDir, "cleaning"))){   
  dir.create(file.path(outDir, "cleaning"))
}
```

```{r}
obj <- clean(obj)
c(pcaCellsPlot, genesPlot, UDEPlot, nuPlot) %<-% cleanPlots(obj)

pcaCellsPlot
```

```{r}
genesPlot
```

Run this when B cells need to be removed.

```{r eval=TRUE, include=TRUE}
pdf(file.path(outDir, "cleaning",
              paste0(t, "_", n_it, "_plots_before_cells_exlusion.pdf")))
pcaCellsPlot
genesPlot

dev.off()
```

Run this only in the last iteration, instead of the previous code, when B cells group has not been removed

```{r}
pdf(file.path(outDir, "cleaning",
              paste0(t, "_", n_it, "_plots_before_cells_exlusion.pdf")))
pcaCellsPlot
genesPlot

dev.off()
pcaCellsPlot

```

```{r}
genesPlot
```

To color the PCA based on nu_j (so the cells' efficiency)

```{r}
pdf(file.path(outDir, "cleaning",
              paste0(t, "_plots_PCA_efficiency_colored.pdf")))
UDEPlot

dev.off()

UDEPlot
```

UDE (color) should not correlate with principal components! This is very important.

The next part is used to remove the cells with efficiency too low.

```{r}
plot(nuPlot)
```

We can zoom on the smallest values and, if we detect a clear elbow, we can decide to remove the cells.

```{r}
nuDf = data.frame("nu"= sort(getNu(obj)), "n"=c(1:length(getNu(obj))))
yset = 0.35#threshold to remove low UDE cells
plot.ude <- ggplot(nuDf, aes(x = n, y = nu)) + 
            geom_point(colour = "#8491B4B2", size = 1) + 
            xlim(0, 400) +
            ylim(0,   1) + 
            geom_hline(yintercept = yset, linetype="dashed", color = "darkred") +
            annotate(geom = "text", x = 200, y = 0.25, 
                     label = paste("to remove cells with nu < ", yset), 
                     color = "darkred", size = 4.5)


pdf(file.path(outDir, "cleaning", paste0(t, "_plots_efficiency.pdf")))
plot.ude
dev.off()

plot.ude
```

We also save the defined threshold in the metadata and re-run the estimation

```{r}
obj <- addElementToMetaDataset(obj, "Threshold low UDE cells:", yset) 

cellsToRemove = rownames(nuDf)[nuDf[["nu"]] < yset]
obj <- dropGenesCells(obj, genes = c(), cells = cellsToRemove)
```

Repeat the estimation after the cells are removed

```{r}
obj <- clean(obj)
c(pcaCellsPlot, genesPlot, UDEPlot, nuPlot) %<-% cleanPlots(obj)

pcaCellsPlot
```

In case we do not want to remove anything, we can run:

```{r}
pdf(file.path(outDir, "cleaning", paste(t, "_plots_efficiency.pdf")))

UDEPlot

dev.off()
```

## COTAN analysis

In this part, all the contingency tables are computed and used to get the statistics.

```{r}
obj = estimateDispersionBisection(obj, cores = 10)
```

COEX evaluation and storing

```{r}
obj = calculateCoex(obj)

# saving the structure
saveRDS(obj, file = file.path(outDir, paste0(t, ".cotan.RDS")))
```

## Automatic run

It is also possible to run a directly a single function if we don't want to clean anything.

```{r}
obj <- automaticCOTANObjectCreation(
  raw = test.dataset.col,
  GEO = "test", sequencingMethod = "10X", sampleCondition = "test.dataset.col",
  saveObj = FALSE, outDir = outDir, cores = 10)
```

# Cell cluster

The next step will find all homogeneous clusters using a GDI check on each cluster.

```{r}
clusters <- cellsUniformClustering(obj, cores = 10, saveObj = FALSE, outDir = outDir)
obj <- addClusterization(obj, clName = "test", clusters = clusters)
```

Than we can perform a sort of differential expression to detect which genes are enriched or depleted in each cluster.

```{r}
c(coexDF, pvalDF) %<-% DEAOnClusters(obj)
obj <- addClusterizationCoex(obj, clName = "test", coexDF = coexDF)
```

Using the cluster distance, based on the whole transcriptome, we can check if any of the closest clusters can together form a still uniform cluster. We will keep this clusterization for the further analysis.

```{r}
c(mergedClusters, mergedCoexDF, mergedPValueDf) %<-%
  mergeUniformCellsClusters(objCOTAN = obj, clusters = clusters, cores = 10,
                            distance = "cosine", hclustMethod = "ward.D2",
                            saveObj = FALSE, outDir = outDir)

obj <- addClusterization(obj, clName = "merged",
                         clusters = mergedClusters, coexDF = mergedCoexDF)
```

Coex heatmap for clustered cells

```{r}
obj <- estimateDispersionNuBisection(obj, cores = 10, enforceNuAverageToOne = FALSE)

obj <- calculateCoex(obj, actOnCells = TRUE)

cellsHPlot <- cellsHeatmapPlot(objCOTAN = obj, clusters = clusters)

plot(cellsHPlot)
```

Use cosine distance to plot nearest clusters

```{r}
######## This is the best: cosine dissimilarity
tree <- hclust(cosineDissimilarity(mergedCoexDF), method = "ward.D2")

dend <- as.dendrogram(tree)
plot(dend)
```

# Analysis of the elaborated data

## GDI

The next function can directly plot the GDI for the dataset with the 1.5 thresholds (in red) and the two higher quantiles (in blue). We can also define some gene sets (in this case three) that we want to specifically label in the GDI plot.

```{r}
AA <- sample(getGenes(obj), size = 5)
BB <- sample(getGenes(obj), size = 5)
CC <- sample(getGenes(obj), size = 5)

genes.list <- list("AA" = AA,"BB" = BB,"CC" = CC)

# needs to be recalculated after the changes in nu/dispersion above
obj <- calculateCoex(obj, actOnCells = FALSE)

GDIPlot(obj, cond = "test", genes = genes.list)
```

If a more complex plot is needed, or if we want to analyze more in detail the GDI data, we can get directly the GDI data frame.


```{r}
quant.p = calculateGDI(obj)

head(quant.p)
```

The percentage of cells expressing the gene in the third column of this dataframe is reported.

## Heatmaps

For the Gene Pair Analysis, we can plot a heatmap with the coex values between two gene sets. To do so we need to define, in a list, the different gene sets (list.genes). Then in the function parameter sets w,e can decide which sets need to be considered (in the example from 1 to 3). In the condition parameter we should insert an array with each file name prefix to be considered (in the example, the file name is "E17.5_cortex").

```{r}
AA <- sample(rownames(quant.p[quant.p$GDI > 2,]),size = 5)
BB <- sample(rownames(quant.p[quant.p$GDI > 2,]),size = 5)
CC <- sample(rownames(quant.p[quant.p$GDI > 2,]),size = 5)


list.genes = list("Ref.col"= BB, "AA"=AA, "Const."=CC )

heatmapPlot(genesLists = list.genes, sets = c(1:3), conditions = c("test"), dir = outDir)
```

We can also plot a general heatmap of coex values based on some markers like the following one.

```{r}
genesHeatmapPlot(obj, primaryMarkers = AA, pValue = 0.001, symmetric = TRUE)
```

```{r}
genesHeatmapPlot(obj, primaryMarkers = AA, secondaryMarkers = BB, symmetric = FALSE, pValue = 0.001)
```

## Get data tables

Sometimes we can also be interested in the numbers present directly in the contingency tables for two specific genes. To get them we can use two functions:

contingencyTables() to produce the observed and expected data

```{r}
c(observedCT, expectedCT) %<-% contingencyTables(obj, g1 = "EIF3F", g2 = "SLC37A1")
print("Observed CT")
observedCT
print("Expected CT")
expectedCT
```

Another useful function is getGenesCoex(). This can be used to extract the whole or a partial coex matrix from a `COTAN` object.

```{r}
# For the whole matrix
coex <- getGenesCoex(obj, zeroDiagonal = FALSE)
coex[1:5, 1:5]
```

```{r}
# For a partial matrix
coex <- getGenesCoex(obj, genes = c("CEP104", "TNFRSF25", "ZBTB48", "STIM1",
                                    "TRIM5", "APBB1", "DNHD1"))
head(coex)
```

The next few lines are just to clean.

```{r}
if (file.exists(paste0(outDir, t, ".cotan.RDS"))) {
  #Delete file if it exists
  file.remove(paste0(outDir, t, ".cotan.RDS"))
}
unlink(paste0(outDir, "cleaning"), recursive = TRUE)

print(sessionInfo())
```
