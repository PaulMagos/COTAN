% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cellsUniformClustering.R,
%   R/checkClusterUniformity.R, R/mergeUniformCellsClusters.R
\name{cellsUniformClustering}
\alias{cellsUniformClustering}
\alias{checkClusterUniformity}
\alias{mergeUniformCellsClusters}
\title{Uniform Clusters}
\usage{
cellsUniformClustering(
  objCOTAN,
  GDIThreshold = 1.5,
  cores = 1L,
  maxIterations = 25L,
  saveObj = TRUE,
  outDir = "."
)

checkClusterUniformity(
  objCOTAN,
  cluster,
  cells,
  GDIThreshold = 1.5,
  cores = 1L,
  saveObj = TRUE,
  outDir = "."
)

mergeUniformCellsClusters(
  objCOTAN,
  clusters = NULL,
  GDIThreshold = 1.5,
  cores = 1,
  distance = "cosine",
  hclustMethod = "ward.D2",
  saveObj = FALSE,
  outDir = "."
)
}
\arguments{
\item{objCOTAN}{a \code{COTAN} object}

\item{GDIThreshold}{the threshold level that discriminates uniform clusters.
It defaults to \eqn{1.5}}

\item{cores}{number cores used}

\item{maxIterations}{Max number of re-clustering iterations. It defaults to
\eqn{25}.}

\item{saveObj}{Boolean flag; when \code{TRUE} saves intermediate analyses and
plots to file}

\item{outDir}{an existing directory for the analysis output. The effective
output will be paced in a sub-folder.}

\item{cluster}{the tag of the cluster}

\item{cells}{the cells in the cluster}

\item{clusters}{The clusterization to merge. If not given the last available
clusterization will be used, as it is probably the most significant!}

\item{distance}{type of distance to use. It defaults to \code{"cosine"}, but
\code{"euclidean"} is also available)}

\item{hclustMethod}{It defaults is \code{"ward.D2"} but can be any of the methods
defined by the \code{\link[stats:hclust]{stats::hclust()}} function.}
}
\value{
\code{cellsUniformClustering} returns the newly found clusterization

\code{checkClusterUniformity} returns \code{TRUE} when the cluster is uniform,
\code{FALSE} otherwise.

a \code{list} with "clusters", "coexDF" and "pValueDF"
}
\description{
This group of functions takes in input a \code{COTAN} object and
handle the task of dividing the dataset into \strong{Uniform Clusters}, that is
clusters that have an homogeneous genes' expression.

\code{cellsUniformClustering} finds a \strong{Uniform} clusterizations by
means of the \code{GDI}

\code{checkClusterUniformity} takes a \code{COTAN} object and a cells'
cluster and checks whether the latter is \strong{uniform} by GDI.

\code{mergeUniformCellsClusters} takes in a \strong{uniform}
clusterization and iteratively checks whether merging two \emph{near} clusters
would form a \strong{uniform} cluster still.
}
\details{
In \code{cellsUniformClustering}, once a preliminary \emph{clusterization} is
obtained from the \code{Seurat} package methods, each cluster is checked for
\strong{uniformity} via the function \code{\link[=checkClusterUniformity]{checkClusterUniformity()}}. Once all
clusters are checked, all cells from the \strong{non-uniform} clustersare pooled
together for another iteration of the entire process, until all clusters
are deemed \strong{uniform}. In the case only a few cells are left out
(\eqn{\leq 50}), those are flagged as \code{"not_clustered"} and the process is
stopped.

\code{checkClusterUniformity} runs \code{COTAN} to check whether the GDI is
lower than the given \code{GDIThreshold} for the \eqn{99\%} of the genes. If the
GDI results to be too high for too many genes, the cluster is deemed
\strong{non-uniform}.

\code{mergeUniformCellsClusters} uses the \emph{cosine distance} and the
\code{\link[stats:hclust]{stats::hclust()}} function to establish \emph{near clusters pairs}. It will use
the \code{\link[=checkClusterUniformity]{checkClusterUniformity()}} function to check whether the merged
clusters are \strong{uniform}. The function will stop once no \emph{near pairs} of
clusters are mergeable.
}
\examples{
data("raw.dataset")

objCOTAN <- automaticCOTANObjectCreation(raw = raw.dataset,
                                         GEO = "S",
                                         sequencingMethod = "10X",
                                         sampleCondition = "Test",
                                         cores = 12,
                                         saveObj = FALSE)

clusters <- cellsUniformClustering(objCOTAN, cores = 12,
                                   saveObj = FALSE)

checkClusterUniformity(objCOTAN,
                       cluster = clusters[1],
                       cells = getCells(objCOTAN)[clusters \%in\% clusters[1]],
                       cores = 12,
                       saveObj = FALSE)

objCOTAN <- addClusterization(objCOTAN, clName = "uniformClusters",
                              clusters = clusters)

mergedList <- mergeUniformCellsClusters(objCOTAN,
                                        clusters = clusters,
                                        cores = 12,
                                        distance = "cosine",
                                        hclustMethod = "ward.D2",
                                        saveObj = FALSE)

objCOTAN <- addClusterization(objCOTAN, clName = "mergedUniformClusters",
                              clusters = mergedList[["clusters"]],
                              coexDF = mergedList[["coexDF"]])

}
